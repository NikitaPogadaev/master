#include <vector>
#include <algorithm>
#include <iostream>
using namespace std;

template<typename T>
class Deque {
private:
    const size_t  backet_size = 4;
    size_t c_backet;
    size_t sz;
    size_t nach1;
    size_t nach2;
    size_t kon1;
    size_t kon2;
    vector<T*> dq;
public:
    Deque() {

        c_backet = 3;
        sz = 0;
        nach1 = 1;
        nach2 = 0;
        kon1 = 1;
        kon2 = 0;
        T* temp1 = reinterpret_cast<T*>(new int8_t[sizeof(T) * backet_size]);
        T* temp2 = reinterpret_cast<T*>(new int8_t[sizeof(T) * backet_size]);
        T* temp3 = reinterpret_cast<T*>(new int8_t[sizeof(T) * backet_size]);
        dq.push_back(temp1);
        dq.push_back(temp2);
        dq.push_back(temp3);
    }
    Deque(size_t n, const T& value = T()) {
        if (n > 0) {
            c_backet = max(((n / backet_size + 1) * 2), size_t(4));
            sz = n;
            nach1 = c_backet / 4;
            nach2 = 0;
            kon1 = nach1 + (n - 1) / backet_size;
            kon2 = (n - 1) % backet_size;
            dq.assign(c_backet, nullptr);
            size_t g = nach1;
            size_t i = 0;
            for (size_t i1 = 0; i1 < dq.size(); ++i1) {
                T* temp = reinterpret_cast<T*>(new int8_t[sizeof(T) * backet_size]);
                dq[i1] = temp;
            }
            try {
                for (; g <= kon1; ++g) {
                    for (i = 0; (i < backet_size) && (i + backet_size * (g - nach1) < sz); ++i) {
                        new(dq[g] + i)T(value);
                    }
                }
            }
            catch (...) {
                for (size_t j = 0; j < i; j++) {
                    (dq[g] + j)->~T();
                }
                for (size_t j = nach1; j < g; j++) {
                    for (size_t j1 = 0; j1 < backet_size; ++j1) {
                        (dq[j] + j1)->~T();
                    }
                }
                for (size_t j = 0; j < dq.size(); ++j) {
                    delete[] reinterpret_cast<int8_t*>(dq[j]);
                }
                dq.clear();
                dq.shrink_to_fit();
                throw;
            }
        }

    }
    Deque(const Deque<T>& D1) {
        c_backet = D1.c_backet;
        kon1 = D1.kon1;
        kon2 = D1.kon2;
        sz = D1.sz;
        nach1 = D1.nach1;
        nach2 = D1.nach2;
        dq.assign(c_backet, nullptr);
        size_t g = nach1;
        size_t i = 0;
        for (size_t i1 = 0; i1 < dq.size(); ++i1) {
            T* temp = reinterpret_cast<T*>(new int8_t[sizeof(T) * backet_size]);
            dq[i1] = temp;
        }
        try {
            for (; g <= kon1; ++g) {
                if (g == nach1)i = nach2;
                else i = 0;
                for (; (i < backet_size) && (i + backet_size * (g - nach1) < sz); ++i) {
                    new(dq[g] + i)T(D1.dq[g][i]);
                }
            }
        }
        catch (...) {
            if (g == nach1) {
                for (size_t j = nach2; j < i; j++) {
                    (dq[g] + j)->~T();
                }
            }
            else {
                for (size_t j = nach2; j < backet_size; j++) {
                    (dq[nach1] + j)->~T();
                }
                for (size_t j = 0; j < i; j++) {
                    (dq[g] + j)->~T();
                }
                for (size_t j = nach1 + 1; j < g; j++) {
                    for (size_t j1 = 0; j1 < backet_size; ++j1) {
                        (dq[j] + j1)->~T();
                    }
                }
                for (size_t j = 0; j < dq.size(); ++j) {
                    delete[] reinterpret_cast<int8_t*>(dq[j]);
                }
            }
            dq.clear();
            dq.shrink_to_fit();
            throw;
        }

    }

    Deque& operator=(const Deque<T>& D1) {
        if (nach1 != kon1) {
            for (size_t j = nach2; j < backet_size; j++) {
                (dq[nach1] + j)->~T();
            }
            for (size_t j = 0; j <= kon2; j++) {
                (dq[kon1] + j)->~T();
            }
            for (size_t j = nach1 + 1; j < kon1; j++) {
                for (size_t j1 = 0; j1 < backet_size; ++j1) {
                    (dq[j] + j1)->~T();
                }
            }
        }
        else {
            for (size_t j = nach2; j < kon2; j++) {
                (dq[nach1] + j)->~T();
            }
        }
        for (size_t j = 0; j < dq.size(); ++j) {
            delete[] reinterpret_cast<int8_t*>(dq[j]);
        }
        c_backet = D1.c_backet;
        kon1 = D1.kon1;
        kon2 = D1.kon2;
        sz = D1.sz;
        nach1 = D1.nach1;
        nach2 = D1.nach2;
        dq.assign(c_backet, nullptr);
        size_t g = nach1;
        size_t i = 0;
        for (size_t i1 = 0; i1 < dq.size(); ++i1) {
            T* temp = reinterpret_cast<T*>(new int8_t[sizeof(T) * backet_size]);
            dq[i1] = temp;
        }
        try {
            for (; g <= kon1; ++g) {
                if (g == nach1)i = nach2;
                else i = 0;
                for (; (i < backet_size) && (i + backet_size * (g - nach1) < sz); ++i) {
                    new(dq[g] + i)T(D1.dq[g][i]);
                }
            }
        }
        catch (...) {
            if (g == nach1) {
                for (size_t j = nach2; j < i; j++) {
                    (dq[g] + j)->~T();
                }
            }
            else {
                for (size_t j = nach2; j < backet_size; j++) {
                    (dq[nach1] + j)->~T();
                }
                delete[] reinterpret_cast<int8_t*>(dq[nach1]);
                for (size_t j = 0; j < i; j++) {
                    (dq[g] + j)->~T();
                }
                delete[] reinterpret_cast<int8_t*>(dq[g]);
                for (size_t j = nach1 + 1; j < g; j++) {
                    delete[] dq[j];
                }
            }
            dq.clear();
            dq.shrink_to_fit();
            throw;
        }
        return *this;
    }

    ~Deque() {
        if (sz > 0) {
            if (nach1 != kon1) {
                for (size_t j = nach2; j < backet_size; j++) {
                    (dq[nach1] + j)->~T();
                }
                for (size_t j = 0; j <= kon2; j++) {
                    (dq[kon1] + j)->~T();
                }
                for (size_t j = nach1 + 1; j < kon1; j++) {
                    for (size_t j1 = 0; j1 < backet_size; ++j1) {
                        (dq[j] + j1)->~T();
                    }
                }
            }
            else {
                for (size_t j = nach2; j < kon2; j++) {
                    (dq[nach1] + j)->~T();
                }
            }
        }
        for (size_t j = 0; j < dq.size(); ++j) {
            delete[] reinterpret_cast<int8_t*>(dq[j]);
        }
    }



    size_t size() {
        return sz;
    }
    size_t size()const {
        return sz;
    }

    T& operator[](size_t i1) {
        return dq[nach1 + (i1 + nach2) / backet_size][(i1 + nach2) % backet_size];
    }
    const T& operator[](size_t i1) const {
        return dq[nach1 + (i1 + nach2) / backet_size][(i1 + nach2) % backet_size];
    }
    T& at(size_t i1) {
        if (i1 >= sz) throw std::out_of_range("");
        else return dq[nach1 + (i1 + nach2) / backet_size][(i1 + nach2) % backet_size];
    }
    const T& at(size_t i1) const {
        if (i1 >= sz)throw std::out_of_range("");
        else return dq[nach1 + (i1 + nach2) / backet_size][(i1 + nach2) % backet_size];
    }
    void grow_buffer_up() {

            c_backet *= 2;
            size_t i1 = 0;
            vector<T *> dq1(c_backet, nullptr);
        try {
            for (; i1 < dq.size(); ++i1) {
                T *temp = reinterpret_cast<T *>(new int8_t[sizeof(T) * backet_size]);
                dq1[c_backet / 2 + i1] = temp;
            }
        }
        catch(...){
            c_backet/=2;
            for(size_t j=0;j<i1;++j){
                delete[] reinterpret_cast<int8_t*>(dq1[j]);
            }
            throw;
        }
            for (size_t i = 0; i < dq.size(); ++i)
                dq1[i] = dq[i];
            dq = dq1;

    }
    void grow_buffer_down() {
        c_backet *= 2;
        vector<T*>dq1(c_backet, nullptr);
        size_t i1=0;
        try {
            for (; i1 < dq.size(); ++i1) {
                T *temp = reinterpret_cast<T *>(new int8_t[sizeof(T) * backet_size]);
                dq1[i1] = temp;
            }
        }
        catch(...){
            c_backet/=2;
            for(size_t j=0;j<i1;++j){
                delete[] reinterpret_cast<int8_t*>(dq1[j]);
            }
            throw;
        }
        for (size_t i = 0; i < dq.size(); ++i)
            dq1[c_backet / 2 + i] = dq[i];
        nach1 += c_backet / 2;
        kon1 += c_backet / 2;
        dq = dq1;
    }
    void push_back(const T& value) {

        //try {
        if (sz > 0) {
            if (kon2 == backet_size - 1) {
                new(dq[kon1 + 1])T(value);
                ++kon1;
                kon2 = 0;
            }
            else {
                new(dq[kon1] + kon2 + 1)T(value);
                ++kon2;
            }
            if ((kon1 == dq.size() - 1) && (kon2 == backet_size - 1))grow_buffer_up();
        }
        else {
            new(dq[kon1])T(value);
        }
        ++sz;
        //}
        //catch (...) { throw; }
    }
    void push_front(const T& value) {
        //try {
        if (sz > 0) {
            if (nach2 == 0) {
                new(dq[nach1 - 1] + backet_size - 1)T(value);
                --nach1;
                nach2 = backet_size - 1;
            }
            else {
                new(dq[nach1] + nach2 - 1)T(value);
                --nach2;
            }
            if ((nach1 == 0) && (nach2 == 0)) grow_buffer_down();
        }
        else {
            new(dq[nach1])T(value);
        }
        ++sz;
        //}
        //catch (...) { throw; }
    }
    void pop_back() {
        //if (kon2 == backet_size - 1)delete[] reinterpret_cast<int8_t*>(dq[kon1 + 1]);
        (dq[kon1] + kon2)->~T();
        if (kon2 == 0) {
            kon2 = backet_size - 1;
            --kon1;
        }
        else --kon2;
        if (sz > 0)--sz;
    }
    void pop_front() {
        //if (nach2 == 0)delete[] reinterpret_cast<int8_t*>(dq[nach1 - 1]);
        (dq[nach1] + nach2)->~T();
        if (nach2 == backet_size - 1) {
            nach2 = 0;
            ++nach1;
        }
        else ++nach2;
        --sz;
    }


    template<bool IsConst>
    struct common_iterator {
    private:
        int num1;
        int num2;
        int backet_size = 4;
        using T_type = std::conditional_t<IsConst, const T&, T&>;
        using T_ptr_type = std::conditional_t<IsConst, const T*, T*>;
        T_ptr_type ptr;
        const vector<T*>* dq;
    public:
        using iterator_category = std::random_access_iterator_tag;
        using value_type = T;
        using pointer = T_ptr_type;
        using reference = T_type;
        using difference_type = std::ptrdiff_t;
        common_iterator(T_ptr_type temp, int a, int b, const vector<T*>* vc) :num1(a), num2(b), ptr(temp), dq(vc) {
        }
        /*common_iterator(const common_iterator<IsConst>& it){
            ptr = it.ptr;
            num1 = it.num1;
            num2 = it.num2;
        }
        common_iterator<IsConst>& operator=(const common_iterator<IsConst>& it){
            ptr = it.ptr;
            num1 = it.num1;
            num2 = it.num2;
            return *this;
        }*/
        T_type operator*() {
            return *ptr;
        }
        T_ptr_type operator->() {
            return ptr;
        }

        common_iterator<IsConst>& operator++() {
            if (num2 == backet_size - 1) {
                num2 = 0;
                num1++;
                ptr = (*dq)[num1];
            }
            else {
                num2 += 1;
                ++ptr;
            }
            return *this;
        }
        common_iterator<IsConst>& operator++(int) {
            common_iterator<IsConst> i(*this);
            if (num2 == backet_size - 1) {
                num2 = 0;
                num1 += 1;
                ptr = (*dq)[num1];
            }
            else {
                num2 += 1;
                ++ptr;
            }
            return i;
        }
        common_iterator<IsConst>& operator--() {
            if (num2 == 0) {
                num2 = backet_size - 1;
                num1 -= 1;
                ptr = (*dq)[num1] + backet_size - 1;
            }
            else {
                num2 -= 1;
                --ptr;
            }
            return *this;
        }
        common_iterator<IsConst>& operator--(int) {
            common_iterator<IsConst> i(*this);
            if (num2 == 0) {
                num2 = backet_size - 1;
                num1 -= 1;
                ptr = (*dq)[num1] + backet_size - 1;
            }
            else {
                num2 -= 1;
                --ptr;
            }
            return i;
        }
        common_iterator<IsConst>& operator+=(int a) {
            num1 = num1 + ((num2 + a) / backet_size);
            if (num2 + a - ((num2 + a) / backet_size) * backet_size < 0)num1--;
            num2 = (((num2 + a) % backet_size) + backet_size) % backet_size;
            ptr = (*dq)[num1] + num2;
            return *this;
        }
        common_iterator<IsConst>& operator-=(int a) {
            num1 = num1 + ((num2 - a) / backet_size);
            if (num2 - a - ((num2 - a) / backet_size) * backet_size < 0)num1--;
            num2 = (((num2 - a) % backet_size) + backet_size) % backet_size;
            ptr = (*dq)[num1] + num2;
            return *this;
        }
        bool operator== (const common_iterator<IsConst>& iter) {
            return ptr == iter.ptr;
        }

        bool operator!= (const common_iterator<IsConst>& iter) {
            return !(ptr == iter.ptr);
        }

        bool operator<= (const common_iterator<IsConst>& iter) {
            if (num1 == iter.num1)
                return (num2 <= iter.num2);
            else
                return (num1 <= iter.num1);
        }

        bool operator>= (const common_iterator<IsConst>& iter) {
            if (num1 == iter.num1)
                return (num2 >= iter.num2);
            else
                return (num1 >= iter.num1);
        }

        bool operator< (const common_iterator<IsConst>& iter) {
            return (*this != iter) && (*this <= iter);
        }

        bool operator> (const common_iterator<IsConst>& iter) {
            return (*this != iter) && (*this >= iter);
        }



        bool operator== (const common_iterator<IsConst>& iter)const {
            return ptr == iter.ptr;
        }

        bool operator!= (const common_iterator<IsConst>& iter)const {
            return !(ptr == iter.ptr);
        }

        bool operator<= (const common_iterator<IsConst>& iter)const {
            if (num1 == iter.num1)
                return (num2 <= iter.num2);
            else
                return (num1 <= iter.num1);
        }

        bool operator>= (const common_iterator<IsConst>& iter)const {
            if (num1 == iter.num1)
                return (num2 >= iter.num2);
            else
                return (num1 >= iter.num1);
        }

        bool operator< (const common_iterator<IsConst>& iter)const {
            return (*this != iter) && (*this <= iter);
        }

        bool operator> (const common_iterator<IsConst>& iter)const {

            return (*this != iter) && (*this >= iter);
        }




        common_iterator<IsConst> operator+(int b) {

            common_iterator<IsConst> temp(*this);
            temp += b;
            return temp;
        }
        common_iterator<IsConst> operator-(int b) {

            common_iterator<IsConst> temp(*this);
            temp -= b;
            return temp;
        }
        int operator-(const common_iterator& b) {

            return (num1 - b.num1) * backet_size + (num2 - b.num2);
        }
        friend class Deque;
    };



    using iterator = common_iterator<false>;
    using const_iterator = common_iterator<true>;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    iterator begin() {

        return iterator(dq[nach1] + nach2, nach1, nach2, &dq);
    }
    iterator end() {

        iterator it(dq[kon1] + kon2, kon1, kon2, &dq);
        ++it;
        return it;
    }
    const_iterator cbegin() {

        return const_iterator(dq[nach1] + nach2, nach1, nach2, &dq);
    }
    const_iterator cend() {

        const_iterator it(dq[kon1] + kon2, kon1, kon2, &dq);
        ++it;
        return it;
    }
    reverse_iterator rend() {

        return reverse_iterator(begin() - 1);
    }
    reverse_iterator rbegin() {

        return reverse_iterator(end() - 1);
    }
    const_reverse_iterator crend() {

        return const_reverse_iterator(cbegin() - 1);
    }
    const_reverse_iterator crbegin() {

        return const_reverse_iterator(cend() - 1);
    }


    const_iterator begin()const {

        return const_iterator(dq[nach1] + nach2, nach1, nach2, &dq);
    }
    const_iterator end() const {

        const_iterator it(dq[kon1] + kon2, kon1, kon2, &dq);
        ++it;
        return it;
    }
    const_iterator cbegin()const {

        return const_iterator(dq[nach1] + nach2, nach1, nach2, &dq);
    }
    const_iterator cend()const {

        const_iterator it(dq[kon1] + kon2, kon1, kon2, &dq);
        ++it;
        return it;
    }
    const_reverse_iterator rend() const {

        return const_reverse_iterator(begin() - 1);
    }
    const_reverse_iterator rbegin()const {

        return const_reverse_iterator(end() - 1);
    }
    const_reverse_iterator crend()const {

        return const_reverse_iterator(cbegin() - 1);
    }
    const_reverse_iterator crbegin()const {

        return const_reverse_iterator(cend() - 1);
    }


    void insert(iterator it, const T& value) {

        iterator k(--end());
        T el = dq[kon1][kon2];
        while (k > it) {
            iterator k1(k);
            (k1.ptr)->~T();
            new(k1.ptr)T(*(--k));
        }
        (k.ptr)->~T();
        new(k.ptr)T(value);
        push_back(el);
    }
    void erase(iterator it) {

        iterator k(it), en(--end());
        while (k != en) {
            iterator k1(k);
            (k1.ptr)->~T();
            new(k1.ptr)T(*(++k));
        }
        pop_back();
    }

};






/*int main()
{
	Deque<int> kek;
	kek.push_front(814359);
	kek.push_front(4359);
	kek.push_front(819);
	kek.push_back(9019);
	kek.push_back(9019);
	kek.push_front(9019);
	kek.push_back(111);
	kek.push_front(9523239);

	auto kok = kek.begin() + 2;
	kek.insert(kok, 678887);
	cout << kek.end() - kek.begin() << endl;
	for (auto i = 0; i < (kek.size()); ++i) {
		cout << kek[i] << " ";
	}
	cout << endl;
	kek.erase(kok);
	kek.pop_back();
	kek.pop_front();
	cout << kek.end() - kek.begin() << endl;
	for (auto i = kek.begin(); i != (kek.end()); ++i) {
		cout << *i << " ";
	}
	Deque<int> d(334000, 1);
	for (int i = 0; i < d.size(); ++i)d[i] = i;
	Deque<int>::iterator left = d.begin() + 100'000;
	Deque<int>::iterator right = d.end() - 233'990;
	while (d.begin() != left) d.pop_front();
	while (d.end() != right) d.pop_back();

	cout << endl << endl << d.size() << endl << endl;

}*/
